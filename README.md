# 이름: 이 록찬
## 학번: 202330316

# 11월27일 강의 내용 메모
## 스택 (Stack) 관련 용어
⊙ 후입선출(Last In First Out - LIFO): 가장 나중에 넣은 데이터를 가장 먼저 꺼내는 작업
⊙ 푸시: 스택에 데이터를 넣는 작업
⊙   팝: 스택에서 데이터를 꺼내는 작업
⊙   꼭대기: 푸시, 팝 작업을 하는 위치
⊙   바닥: 스택의 가장 밑바닥 부분

스택 기본 함수
Initialize
push: 푸시 함수. 데이터를 넣기
pop: 팝 함수. 꼭데기 데이터 꺼내기
peek: top의 data 읽기
Clear(): 스택의 모든 데이터를 삭제하는 함수
Capacity(): 용량을 확인하는 함수. 데이터를 넣을 수 있는 최대 공간
Size(): 데이터의 개수를 확인하는 함수
IsEmpty(): 스택이 비어 있는지 검사하는 함수. 비어 있으면 1, 그렇지 않으면 0을 반환
IsFull(): 스택이 가득 찼는지 검사하는 함수. 가득 찼으면 1, 그렇지 않으면 0을 반환
Search(): 임의의 값을 검색하는 함수
Print(): 모든 데이터를 출력하는 함수. 스택의 모든 데이터를 바닥부터 순서대로 출력
Terminate(): 종료 함수. Initialize 함수로 확보한 스택을 해제.
------------------------------------------------------------------------------------
## 큐(Que) 관련 용어
선입선출:(First In First Out - FIFO): 가장 먼저 넣은 데이터를 가장 먼저 꺼내는 작업
인큐(en-queue): 큐에 데이터를 넣는 작업.
디큐(de-queue): 데이터를 꺼내는 작업.
프론트(front): 데이터를 꺼내는 쪽.
리어(rear): 데이터를 넣는 쪽.

## 버블정렬
-인접한 두 데이터를 비교하여 기준에 만족하면 데이터를 서로 교환해서 완성될 때까지 반복하는 정렬 방법.

## 퀵 정렬
-리스트 가운데서 하나의 원소를 고른다. 그리고 이것을 '피벗'이라고한다.
-피벗 앞에는 피벗보다 작은 값의 모든 원소가 오고, 피벗 뒤에는 큰 값의 모든 원소들이 오도록 리스트를 나눈다.
그리고 두가지 리스트에서 또 다시 피벗을 만들고 또 그 안에서 두개의 배열로 다시 나눈다. 더 이상 배열을 쪼갤 수 없을 때까지 계속 진행한다.

--------------------------------------------------------------------------------------------------------
# 11월20일 강의 내용 메모
## 트리에 대하여

-> 순서 트리의 탐색 방법 中 '너비 우선 탐색' → 낮은 레벨에서 시작해 왼쪽에서 오른쪽 방향으로 검색하고 한 레벨에서의 검색이 끝나면 다음 레벨로 내려가는 탐색 방법을 의미함.

-> 순서 트리의 탐색 방법 中 '깊이 우선 탐색' → 스택을 사용하여 현재 노드에서 순서대로 내려간 뒤, 더 이상 갈 곳이 없으면 되돌아와 다른 갈래를 탐색하는 그래프.
** 탐색 알고리즘깊이 우선 탐색에서 가능한 노드 방문 종류에는 "전위 순회", "중위 순회", "후위 순회"가 있다. **

-> 이진트리 → 노드가 왼족 자식과 오른쪽 자식을 갖는 트리이며 노드의 자식은 2명 이하만 유지해야한다. 왼쪽 자식을 다시 루트로 하는 서브 트리를 왼쪽 서브 트리,
반대로 오른쪽 자식을 다시 루트로 하는 서브 트리를 오른족 서브 트리라고한다.

-> 완전이진트리 → 루트부터 노드가 채워져 있으면서 같은 레벨에서는 왼쪽에서 오른쪽으로 노드가 채워져있는 이진트리이며, 높이가 K인 완전이진트리가 가질 수 있는 노드의 최댓값은 2(k+1 제곱)-1개.

-> 해시법: 데이터를 저장할 위치를 간단한 연산으로 구하는 것, 검색뿐만 아니라 추가, 삭제도 효율적으로 수행하는 방법 중 한가지이다.

-> 체인법? 체인법에서 요소를 추가하는 Add 함수? 오픈 주소법?

--------------------------------------------------------------------------------------------------------
# 11월13일 강의 내용 메모
## 리스트에 대하여
-> 선형 리스트의 리스트란? 자료를 나열해놓은 것

-> 선형 리스트에서 노드란? "리스트의 각 요소", 그리고 각각의 노드는 데이터와 다음 노드를 가리키는 포인터를 가지고 있다. 또한 처음과 끝에 있는 노드는 특별히 '머리 노드'와 '꼬리 노드'라고 한다. 또한 하나의 노드에 대해 바로 앞에 있는 노드를 '앞쪽 노드', 뒤에 있는 노드는 '다음 노드'라고 한다.

*노드형 구조체의 자료구조 방식 = 자기참조형

*단어 정의: crnt = '현재 선택한 노드'를 가리키는 포인터(커서) / ISEmpty 함수 = '리스트가 비어 있는지 검사하는 함수' / Search = '노드를 검색하는 함수'

--------------------------------------------------------------------------------------------------------
# 11월6일 강의 내용 메모
## ※ 정렬을 마친 배열 병합하기
-> 병합의 조건: "a, b 모두 정렬이 끝난 배열"

->'각 배열에서 선택한 요소의 값을 비교하여 작은 값의 요소를 꺼내 새로운 배열에 넣는 작업'을 반복하여 정렬을 마치는 배열을 만듬

## ※ qsort 함수 이용 정렬
->qsort 함수는 bsearch 함수와 마찬가지로 int형이나 double형 등의 배열뿐만 아니라 구조체형 배열 등 모든 자료형의 배열에 적용 할 수 있음

->qsort 함수에 전달하는 4개의 인수는 차례대로 배열의 첫 번째 요소에 대한 포인터 - 요소의 개수 - 요소의 크기 - 비교 함수에 대한 포인터 순서이다.

--------------------------------------------------------------------------------------------------------
# 10월31일 강의 내용 메모(10월9일 한글날 휴일 수업 보강)
## ※ 1.버블 정렬 중 패스(pass)
->이웃한 요소를 비교하고 교환하는 작업을 첫번째 요소까지 계속 실행하는 것을 의미

->요소의 개수가 n개인 배열에서 n-1회 비교, 교환을 하고 나면 가장 작은 요소가 맨 처음으로 이동한다. / 이 과정(비교-교환 작업)을 패스라고 한다.

## ※ 2.정렬의 종류 중 단순 선택 정렬
->아직 정렬하지 않은 부분에서 값이 가장 작은 요소를 선택하고 아직 정렬하지 않은 부분의 첫번째 요소와 교환

->교환 과정은? ---아직 정렬하지 않은 부분에서 가장 작은 키의 값을 선택 --- 요소에서 교환하지 않은 첫번째 요소와 교환을 한다.

## ※ 3.셀 정렬 살펴보기
->단순 삽입 정렬의 장점은 살리고 단점은 보완할 정렬 알고리즘

->정렬할 배열의 요소를 그룹으로 나눠 각 그룹별로 단순 삽입 정렬을 수행, 그 그룹을 합치면서 정렬 반복&요소의 이동 횟수를 줄이는 방법

## ※ 4. 4-정렬
->4칸만큼 떨어진 요소를 모아 그룹을 4개로 나누어 정렬하는 방법

->아직 정렬을 마친 상태는 아니지만 정렬을 마친 상태에 가까워짐

## ※ 5. 2-정렬
-> 2칸만큼 떨어진 요소를 모아 두 그룹으로 나누어 2-정렬을 하는 것 /예: 7 1 3 2 8 6 4 5가 있으면 {7,3,8,4}, {1,2,6,5}로 나누어 정렬하는 것

## ※ 6. h-정렬
-> 셀 정렬 과정에서 수행하는 각각의 정렬

## ※ 7. 퀵 정렬
-> 일반적으로 사용되는 아주 빠른 정렬 알고리즘

-> 정렬 요소중 기준 요소를 고른다. 그리고 그 기준보다 이상/이하 그룹으로 나눈다. 이상 그룹에는 pl을 지정해주고, 반대 그룹에는 pr을 지정해준다. 배열로 옮겨주며, pl과 pr이 교차하면 배열 과정이 끝난다.

이때, 높은 것의 그룹을 피벗이라고하고, 그 그룹에 대해 피벗설정과 그룹 나눔을 반복한다. 이후 모든 그룹이 1이 되면 정렬을 마친다.

--------------------------------------------------------------------------------------------------------
# 10월30일 강의 내용 메모
※스택(Stack)이란?
->데이터를 일시적으로 저장하기 위해 사용하는 자료구조

->데이터 입,출력 순서는 후입선출(=LIFO / Last In First Out / 나중에 들어간것이 먼저 나온다)

->스택의 용어:  푸시: 스택에 데이터를 넣는 작업 ↔ 팝: 스택에서 데이터를 꺼내는 작업 / 탑: 스택에 꼭대기 위치

->스택 구조체 - IntStack, 스택의 최대 용량 단위: 'max', 스택의 포인터는 'ptr', 스택의 초기화 함수 'Initialize'

---------------------------------------------------------------------------------------------------------
## ※큐(Queue)란?
-> 데이터를 일시적으로 쌓아 두기 위한 자료구조

-> 가장 먼저 넣은 데이터를 가장 먼저 꺼내는 선입선출 구조를 이룸 (FIFO / First In First Out)

-> 은행 창구에서 차례를 기다리는 대기열이나 마트에서 계산을 기다리는 대기열과 같음
#### ->인큐: 큐에 데이터를 넣는 작업 / 디큐: 큐에서 데이터를 꺼내는 작업
#### -> 프런트: 데이터를 꺼내는 쪽 / 리어: 데어터를 넣는 쪽

## ※링버퍼로 큐 만들기

-> 배열의 처음이 끝과 연결되었다고 보는 자료구조

-> 프런트는 논리적인 ‘맨 처음 요소의 인덱스’ ↔ 리어는 논리적인 '맨 끝 요소의 하나 뒤에 인덱스'

-> 변수 프런트와 리어의 값은 인큐와 디큐를 수행함에 따라 변화하는데, 이 때문에 배열 요소를 앞쪽으로 옮기지 않는 큐를 구현 할 수 있음.

## 정렬에 대해서
#### 정렬이란? 이름, 학번, 키 등 핵심 항목(key)의 대소 관계에 따라 데이터 집합을 일정한 순서로 줄지어 늘어서도록 바꾸는 작업
#### 정렬에서는 오름차순과 내림차순 2가지가 있고, 키값이 작은 데이터를 앞쪽에 놓으면 오름차순, 그 반대는 내림차순이다.
#### 정렬 알고리즘의 안정성: 안정된 정렬이란 같은 값의 키를 가진 요소의 순서과 정렬 전후에도 유지되는것을 뜻한다.
#### 정렬 알고리즘의 핵심 요소에는 교환, 선택, 삽입 3가지가 있다.

#### 버블 정렬의 패스 수행 횟수는 (n-1회, n-2회 ㆍㆍㆍ) - 패스를 1회 수행할 때마다 정렬할 요소가 하나씩 줄어들기 때문, 패스를 K회 수행하면 앞쪽의 요소 K개가 #### 버블 정렬의 알고리즘 개선 - 어떤 시점 이후에 교환이 수행되지 않는다면 그보다 앞쪽의 요소는 이미 정렬을 마친 상태라고 생각해도 좋다.
----------------------------------------------------------------------------------------------------------
# 10월23일 강의 내용 메모
▣검색 알고리즘 - 배열의 종류 및 검색법
-선형 검색: 무작위로 늘어놓은 데이터 모임에서 검색을 수행

*선형검색 다루기 방법: 요소 개수가 n인 배열a에서 값이 key인 요소를 검색하는 코드

*보초법으로 검색 다루기

-이진 검색: 일정한 규칙으로 늘어놓은 데이터 모임에서 아주 빠른 검색을 수행

-해시법: 추가, 삭제가 자주 일어나는 데이터 모임에서 아주 빠른 검색을 수행

-체인법: 같은 해시값의 데이터를 선형 리스트로 연결하는 방법(해시법의 하위버전)

-오픈주소법:데이터를 위한 해시값이 충돌 할 때 재해시하는 방법(해시법의 연결 버전)


# 10월2일 강의 내용 메모
배열 요소를 역순으로 정리하는 코딩 / 구조체에 대하여 / 배우고, 실습 예제를 보며 코딩을 해보았다.

# 9월25일 강의 내용 메모
배열에 관하여 배우고, 그것에 관련된 코딩을 test.c파일에서 하였다.

# 9월18일 강의 내용 메모
For문 + While문에 대해여 배웠고, test.c파일에서 코딩을 해보았다.

# 9월11일 강의 내용 메모

# 9월4일 강의 내용 메모

[문자 크기](#h1에-해당) / [리스트](#리스트)
# 문자 크기 구분
```md
# h1에 해당
## h2에 해당
### h3에 해당
#### h4에 해당
##### h5에 해당
###### h6에 해당
```
*이탤릭 체*

**볼드 체**

--- 
* 언오더드 리스트(탭키 실행)
* 탭0
    * 탭1
        * 탭2
            * 탭3 변화없음

1. 또 다른 기능 활용

* 아래는 코드블럭(line 21~28)
```c
#include <stdio.h>
int main()
{
    printf("Hello, World!\n);
    return 0;
}
```
인라인 코드 블럭 예 : `<br>` 또 다른 예2 : `Ctrl`+`A` =전체 선택 기능

# 외부링크
[구글로 가기](https://google.com "구글 바로가기 링크")

# [내부] (#)